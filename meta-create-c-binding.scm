(use-modules (ice-9 textual-ports))
(use-modules (ice-9 format))
(use-modules (srfi srfi-1))

(define functions-file (car (cdr (command-line))))

(define (read-lines port lines)
  (let ((line (get-line port)))
    (if (eof-object? line)
        lines
        (read-lines port (cons line lines)))))

(define (read-specifications path)
  (format #t "//Reading the functions definitions from: ~a\n\n" path)
  (let* ((port (open-input-file path))
         (results (read-lines port '())))
    (close-port port)
    (reverse results)))

(define header
  (list
   "/*\n"
   " * This code was automatically generated by meta-create-c-binding.scm.\n"
   " * Do not edit directly\n"
   " */\n"
   "\n"))

(define (write-lines lines)
  (map display
       lines))

(define generate-function-lines)

(define (expand-return arguments)
  (list
   (format #f "return ~a;\n" (car arguments))))

(define (expand-group arguments)
  (let ((group-pseudocodes (car arguments)))
    (append '("{\n")
            (map (lambda (string) (string-append "\t" string))
                 (generate-function-lines group-pseudocodes))
            '("}\n\n"))))

(define (expand-to-py-object-conversion arguments)
  (let ((input-name (car arguments))
        (result-name (cadr arguments)))
    (list
     (format #f "SCM ~a;\n" result-name)
     (format #f "if(~a == NULL) {\n" input-name)
     (format #f "\t~a = create_empty_list();\n" result-name)
     "} else {\n"
     (format #f "\t~a = create_python_scm(~a, \"PyObject\");\n" result-name input-name)
     "}\n")))

(define (expand-function-execute arguments)
  (let ((return-type (car arguments))
        (function-name (cadr arguments))
        (return-variable (list-ref arguments 2)))
    (list
     (format #f "~a ~a;\n" return-type return-variable)
     (format #f "WITH_PYTHON_LOCK(~a = ~a());\n\n" return-variable function-name))))

(define (expand-sub-execute arguments)
  (let ((function-name (car arguments)))
    (list
     (format #f "WITH_PYTHON_LOCK(~a());\n" function-name))))

(define (expand-header arguments)
  (let ((wrapper-name (cadr arguments)))
   (list
    (format #f "SCM ~a()\n" wrapper-name))))

(define (expand-comment arguments)
  arguments)

(define (get-expansion-function type)
  (cond
   ((eqv? type ':comment)
    expand-comment)
   ((eqv? type ':header)
    expand-header)
   ((eqv? type ':sub-execute)
    expand-sub-execute)
   ((eqv? type ':function-execute)
    expand-function-execute)
   ((eqv? type ':to-py-object)
    expand-to-py-object-conversion)
   ((eqv? type ':return)
    expand-return)
   ((eqv? type ':group)
    expand-group)))

(define (expand-pseudo-instruction pseudocode)
  (let ((type (car pseudocode))
        (arguments (cdr pseudocode)))
    (apply (get-expansion-function type) (list arguments))))

(define (generate-function-lines pseudocodes)
  (fold (lambda (pseudo-instruction previous)
          (append previous (expand-pseudo-instruction pseudo-instruction)))
        '()
        pseudocodes))

(define (create-pseudocode specification)
  (let ((return-value (car specification))
        (name (list-ref specification 1))
        (args (list-ref specification 2)))
    `((:comment ,(format "// ~a\n" name))
      (:header ,return-value ,(format #f "~a_wrapper" name))
      (:group ,(if (eq? return-value 'void)
                   `((:sub-execute ,name)
                     (:return SCM_UNSPECIFIED))
                   `((:function-execute ,return-value ,name result)
                     (:to-py-object result scm_result)
                     (:return scm_result)))))))

(define (translate-specification raw-specification)
  (eval-string
   (string-append "'(" raw-specification ")")))

;;; TODO/FIXME refactor from here on. It's hideous
(write-lines header)

(map write-lines
 (map generate-function-lines
      (map (lambda (x)
             (format #f "CURRENT: ~a\n" x)
             x)
       (map create-pseudocode
            (map translate-specification
                 (read-specifications functions-file))))))
