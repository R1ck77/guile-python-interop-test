(use-modules (ice-9 textual-ports))
(use-modules (ice-9 format))
(use-modules (srfi srfi-1))

(define functions-file (car (cdr (command-line))))

(define (read-lines port lines)
  (let ((line (get-line port)))
    (if (eof-object? line)
        lines
        (read-lines port (cons line lines)))))

(define (read-specifications path)
  (format #t "//Reading the functions definitions from: ~a\n\n" path)
  (let* ((port (open-input-file path))
         (results (read-lines port '())))
    (close-port port)
    (reverse results)))

(define header
  (list
   "/*\n"
   " * This code was automatically generated by meta-create-c-binding.scm.\n"
   " * Do not edit directly\n"
   " */\n"
   "\n"))

(define (write-lines lines)
  (map display
       lines))

(define generate-function-lines)

(define (call-argument-from-index index)
  (format #f "call_arg_~d" index))

(define (get-check-function-for-type type)
  (case type
    ((long) "scm_integer_p")
    ((double) "scm_real_p")))

(define (expand-check-value arguments)
  (let ((error-location (car arguments))
        (variable-name (cadr arguments))
        (type (list-ref arguments 2)))
    (list
     (format #f "if(!~a(~a)) {\n" (get-check-function-for-type type) variable-name)
     (format #f "\treturn raise_error(~s, \"Invalid value provided\");\n" error-location)
     (format #f "}\n"))))

(define (get-convert-function-for-type type)
  (case type
    ((long) "convert_to_long")
    ((double) "scm_to_double")))

(define (expand-convert-from-scheme arguments)
  (let ((input-name (car arguments))
        (result-name (cadr arguments))
        (type (list-ref arguments 2)))
    (list
     (format #f "~a ~a = ~a(~a);\n\n" type result-name (get-convert-function-for-type type) input-name))))

(define (expand-return arguments)
  (list
   (format #f "return ~a;\n" (car arguments))))

(define (expand-group arguments)
  (let ((group-pseudocodes (car arguments)))
    (append '("{\n")
            (map (lambda (string) (string-append "\t" string))
                 (generate-function-lines group-pseudocodes))
            '("}\n\n"))))

(define (expand-to-py-object-conversion arguments)
  (let ((input-name (car arguments))
        (result-name (cadr arguments)))
    (list
     (format #f "SCM ~a;\n" result-name)
     (format #f "if(~a == NULL) {\n" input-name)
     (format #f "\t~a = create_empty_list();\n" result-name)
     "} else {\n"
     (format #f "\t~a = create_python_scm(~a, \"PyObject\");\n" result-name input-name)
     "}\n\n")))

(define (create-call-arguments-list arg-names)
  (string-join (map (lambda (name)
                        (format #f "~a" name))
                    arg-names)
               ","))

(define (expand-function-execute arguments)
  (let ((return-type (car arguments))
        (function-name (cadr arguments))
        (arguments-names (list-ref arguments 2))
        (return-variable (list-ref arguments 3)))
    (list
     (format #f "~a ~a;\n" return-type return-variable)
     (format #f "WITH_PYTHON_LOCK(~a = ~a(~a));\n\n" return-variable function-name (create-call-arguments-list arguments-names)))))

(define (expand-sub-execute arguments)
  (let ((function-name (car arguments))
        (arguments-names (cadr arguments)))
    (list
     (format #f "WITH_PYTHON_LOCK(~a(~a));\n" function-name (create-call-arguments-list arguments-names)))))

(define (function-argument-from-index index)
  (format #f "scm_arg_~d" index))

(define (create-function-arguments-list n-arguments)
  (string-join (map (lambda (index)
                      (format #f "SCM ~a" (function-argument-from-index index)))
                    (iota n-arguments))
               ","))

(define (expand-header arguments)
  (let ((wrapper-name (cadr arguments))
        (n-arguments (list-ref arguments 2)))
   (list
    (format #f "SCM ~a(~a)\n" wrapper-name (create-function-arguments-list n-arguments)))))

(define (expand-comment arguments)
  arguments)

(define (get-expansion-function type)
  (cond
   ((eqv? type ':comment)
    expand-comment)
   ((eqv? type ':header)
    expand-header)
   ((eqv? type ':sub-execute)
    expand-sub-execute)
   ((eqv? type ':function-execute)
    expand-function-execute)
   ((eqv? type ':to-py-object)
    expand-to-py-object-conversion)
   ((eqv? type ':return)
    expand-return)
   ((eqv? type ':group)
    expand-group)
   ((eqv? type ':check-value)
    expand-check-value )
   ((eqv? type ':convert-from-scheme)
    expand-convert-from-scheme)))

(define (expand-pseudo-instruction pseudocode)
  (let ((type (car pseudocode))
        (arguments (cdr pseudocode)))
    (apply (get-expansion-function type) (list arguments))))

(define (generate-function-lines pseudocodes)
  (fold (lambda (pseudo-instruction previous)
          (append previous (expand-pseudo-instruction pseudo-instruction)))
        '()
        pseudocodes))

;;; TODO/FIXME generalize for N arguments!
(define (create-arguments-pseudocode-blocks function-name arguments)
  (if (nil? arguments)
      '()
      `((:check-value ,(format #f "Argument ~d for ~a" 0 function-name)
                      ,(function-argument-from-index 0)
                      ,(car arguments))
        (:convert-from-scheme scm_arg_0 call_arg_0 ,(car arguments)))))

(define (create-pseudocode specification)
  (let ((return-value (car specification))
        (name (list-ref specification 1))
        (args (list-ref specification 2)))
    (let* ((args-range (iota (length args)))
           (function-arguments (map function-argument-from-index args-range))
           (call-arguments (map call-argument-from-index args-range))) 
      `((:comment ,(format #f "// ~a\n" name))
        (:header ,return-value ,(format #f "~a_wrapper" name) ,(length args))
        (:group
         (,@(create-arguments-pseudocode-blocks name args)
          ,@(if (eq? return-value 'void)
                `((:sub-execute ,name ,call-arguments)
                  (:return SCM_UNSPECIFIED))
                `((:function-execute ,return-value ,name ,call-arguments result) ;;; ADDED AN ARGUMENT
                  (:to-py-object result scm_result)
                  (:return scm_result)))))))))

(define (translate-specification raw-specification)
  (eval-string
   (string-append "'(" raw-specification ")")))

;;;TODO/FIXME this one only uses the first function and ignores the other!
(define-macro (broken-> value . functions)
  (let ((input (make-symbol "result")))
    `(let ((,input ,value))
       (,(car functions) ,input))))

(define (write-wrappers path-to-templates)
  (map write-lines
       (map generate-function-lines
            (map create-pseudocode
                 (map translate-specification
                      (read-specifications path-to-templates))))))

(write-lines header)
(write-wrappers functions-file)


